Make messaging fire-and-forget rather than requiring a response immediately after getting a message
    test out fire-and-forget by using the msg->port field to store address of dst
    when a message of sent, the sender 

    Will need to modify dgrep to give it a hardcoded listening port???
    current system has dgrep wait for a response immediately after sending request
    could use the same queue system for dgrep.  Then have dgrep listen on a port until it hears
    a reply from all nodes OR a timeout occurs

    Could test the msg_queue with dgrep first


Before we can use queue (which splits recv and sending messages into different threads)
    need sender to also send the listening port.
    this should be included in msg.  struct msg should NOT include the sockfd anymore since we don't want to worry about this
    when dealing at the node level - ip address should be enough

Implement msg_queue and use one of these instead of current arena
    keep a copy of global arena, but rename it global arena.  This is used for all other allocations that must persist through entire lifetime
        of node (just member_list for now...?)
    any other temporary allocations can from either msg_queue (including most temporary allocations?)
    
Listener will recv message using a queue (which has a private memory allocator)
Main thread will use a different queue (with its own private memory allocator) to respond to messages
    when main thread is done handling all message in queue (which is should have exclusive access to)
    it will deallocate all memory, and then lock both queues and swap them

    This system also makes it easier to handle tcp/udp connections in the same way - queue the msg and handle them later in a function
    dedicated to doing so.  This might be slower than resusing a connection... but it would be simplier...

A node introduces itself to introducer
    uses tcp socket to connect to introducer
    introducer adds requester to own membership list
    introducer sends requester membership list
    end tcp connection

    Need to make a tagged union to handle different message types
        MT_DGREP
        MT_JOIN_REQ
        MT_JOIN_RES

Membership protocol
    introducer and new nodes use tcp to make initial connection
    this allows introducer to update its own membership list and new node to get the initial membership list
    after this, at intervals the gossip protocol should occur (including the introducer) using a UDP connection
    will need to add UDP sockets to net.h

Each node will keep an array of messages it receives and reads them when necessary
    this allows us to not worry about connections (and to use UDP)

Nodes send messages to eachother at at set time interval
Nodes maintain a list of know members to gossip with
A single node is the introduce (port 3000), and all nodes first gossip with this node on startup

Implement a membership protocol (let's try gossip style heartbeating with fail/delete and suspicion)
    Consider looking at/using the API provided by the Coursera MP1 project
    failure must be reflected at one node within 3 seconds
        this requires heart-beating at least once per 1.5 seconds (if using 1.5 seconds for TFAIL and 1.5 seconds for TDELETE)
    failure must be reflected in all nodes within 6 seconds
    each machine must join with a version number (using fail-stop rather than fail-recovery model)
    use UDP for membership messaging
    log all joins, voluntary leaves and failures
    Implement a way to drop messages on receiver end (default to 0%)

Implement distributed system visualizer using SDL3
    Use logs to replay nodes leaving/entering???? and detection
